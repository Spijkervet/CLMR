<!DOCTYPE html>
<html lang="en">
	<head>
		<title>CLMR Manifold Explorer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;
			}
			a {
				color: #fff;
			}
		</style>

		<!-- List items with avatar and action -->
		<style>
			.demo-list-control {
			    width: 230px;
			}

			.demo-list-radio {
			    display: inline;
			}

		</style>

		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

	</head>




	<body>
		<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
		<link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.blue_grey-deep_orange.min.css" />
		<script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.min.js"></script>
		<script src="https://d3js.org/d3.v4.min.js"></script>
		<script src="//rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>

		<!-- The drawer is always open in large screens. The header is always shown,
		  even in small screens. -->
		<div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer
            		mdl-layout--fixed-header">
            <header class="mdl-layout__header">
                <div id='header' class="mdl-layout__header-row">
                    <div class="mdl-layout-spacer"></div>
					<nav class="mdl-navigation">
						<h6 id="filename"></h6>
					</nav>
                    <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable
                                mdl-textfield--floating-label mdl-textfield--align-right">

	                    <div class="mdl-textfield__expandable-holder">
	                        <input class="mdl-textfield__input" type="text" name="sample"
	                                  id="fixed-header-drawer-exp">
	                    </div>
                    </div>
                </div>
			</header>
		        <div class="mdl-layout__drawer" id='drawer'>
		            <span class="mdl-layout-title">Manifold Explorer</span>
		            <span style="text-align: center">Contrastive Learning of Musical Representations</span>
					<span style="padding: 10px">INFO: 20 tracks, each with 30 clips of 2.46 seconds of audio, clustered using representations from a frozen, pre-trained CLMR network and fed into t-SNE.
					This pre-trained network learns contrastively, meaning there is no signal anywhere in the network about what music is (no labels).</span>
		        </div>
		    <main class="mdl-layout__content">
			    <div class="page-content">
					<!-- Your content goes here -->

					<div id="container"></div>
				</div>
		    </main>
		</div>

		<script src='webaudiox.js'></script>

		<script>

			// create WebAudio API context
			var context = new AudioContext()

			// Create lineOut
			var lineOut = new WebAudiox.LineOut(context)
			lineOut.volume = 0.4;

			
			var json = $.getJSON({'url': "/data.json", 'async': false});  
			data = JSON.parse(json.responseText);
			var copy = json;
			console.log(data)

			function getData(method, feature, a, b) {
				var key;
				if (method.toString() == "pca") {
					key = method.toString() + feature.toString();
				} else if (method.toString() == "tsne") {
					key = method.toString() + feature.toString() + b.toString() + a.toString();
				} else {
					key = method.toString() + feature.toString() + a.toString() + b.toString();
				}

				// only tsne for now
				key = "tsne"
				console.log(key)
				return data[key];
			}

			var filePaths = data['filenames'];
			var labelColors = data['colors']
			
			console.log(filePaths)


			var renderer, scene, camera, stats;
			var pointclouds;
			var raycaster;
			var mouse = new THREE.Vector2();
			var intersection = null;
			var spheres = [];
			var spheresIndex = 0;
			var clock;
			var mouseHasMoved = false;
			var sound = null;
			var interpolating = false;
			var interpolatingAmount = 0;
			var interpolationSpeed = 0.01;
			var target = null;
			var previousSampleIndex = -1;
			var threshold = 0.1;
			var pointSize = 3;
			var width = 150;
			var length = 150;

			var drawerWidth = document.getElementById("drawer").clientWidth;
			var titleHeight = document.getElementById("header").clientHeight;
			var renderWidth = window.innerWidth - drawerWidth;
			var renderHeight = window.innerHeight - titleHeight;


			init();
			animate();

			function updateGraph() {
				var slider1 = parseInt(document.getElementById("slider1").value) - 1;
				var slider2 = parseInt(document.getElementById("slider2").value) - 1;

				var method = null;
				var methodOptions = document.getElementsByClassName('mdl-radio__button');
				for (var i = 0; methodOptions[i]; ++i) {
					let id = methodOptions[i].id.toString();
					if (methodOptions[i].checked && (id.indexOf("method") != -1)) {
						method = methodOptions[i].value;
						break;
					}
				}

				var feature = null;
				var featureOptions = document.getElementsByClassName('mdl-radio__button');
				for (var i = 0; featureOptions[i]; ++i) {
					let id = featureOptions[i].id.toString();
					if (featureOptions[i].checked && (id.indexOf("feature") != -1)) {
						feature = featureOptions[i].value;
						break;
					}
				}

				if (method == "umap") {
					document.getElementById("sliders").style.visibility = "visible";
					document.getElementById("slider-text-1").innerHTML = "Neighbours";
					document.getElementById("slider-text-2").innerHTML = "Distances";
				} else if (method == "tsne") {
					document.getElementById("sliders").style.visibility = "visible";
					document.getElementById("slider-text-1").innerHTML = "Perplexity";
					document.getElementById("slider-text-2").innerHTML = "Iterations";
				} else if (method == "pca") {
					document.getElementById("sliders").style.visibility = "hidden";
				}

				let targetData = getData(method, feature, slider1, slider2);
				target = generatePositionsFromData(targetData);
				interpolating = true;
				interpolatingAmount = 0;
			}

			function generatePositionsFromData(data) {

				var positions = new Float32Array(data.length * 3);
				for (var i = 0; i < data.length; ++i) {

					let x = data[i]['coordinates'][0] * 3 - 1.5;
					let y = data[i]['coordinates'][1] * 3 - 1.5;
					let z = 0;

					positions[3 * i] = x;
					positions[3 * i + 1] = y;
					positions[3 * i + 2] = z;
				}

				return positions;
			}

			function generatePointCloudGeometry(data) {

				console.log(data)

				var geometry = new THREE.BufferGeometry();
				var positions = generatePositionsFromData(data);

				var colors = new Float32Array(data.length * 3);
				var color = new THREE.Color();
				for (var i = 0; i < data.length; ++i) {

					console.log(labelColors[i])

					color.setHSL(0.8, .8, .5);
					colors[3 * i] = labelColors[i][0]; // color.r;
					colors[3 * i + 1] = labelColors[i][1]; // color.g;
					colors[3 * i + 2] = labelColors[i][2]; // color.b;
				}

				geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
				geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
				geometry.computeBoundingBox();

				return geometry;
			}

			function generatePointcloud(data) {

				var geometry = generatePointCloudGeometry(data);

				var material = new THREE.PointsMaterial({
					size: pointSize,
					vertexColors: THREE.VertexColors,
					sizeAttenuation: false
				});
				var pointcloud = new THREE.Points(geometry, material);
				return pointcloud;
			}

			function init() {

				var container = document.getElementById('container');

				scene = new THREE.Scene();

				clock = new THREE.Clock();

				const near_plane = 10;
				const far_plane = 50;

				// Set up camera and scene
				camera = new THREE.PerspectiveCamera(
				    50,
				    renderWidth / renderHeight,
				    near_plane,
				    far_plane
				);

				camera.applyMatrix( new THREE.Matrix4().makeTranslation( 0,0,40 ) );

				let jsonData = getData("umap", "mfcc", 2, 2);

				var pcBuffer = generatePointcloud(jsonData);
				pcBuffer.scale.set(10, 10, 1);
				pcBuffer.position.set(0, 0, 0);
				scene.add( pcBuffer );

				pointclouds = [ pcBuffer ];


				var sphereGeometry = new THREE.SphereGeometry( 0.1, 20, 20 );
				var sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );

				for ( var i = 0; i < 40; i++ ) {

					var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
					scene.add( sphere );
					spheres.push( sphere );
				}

				//
				renderWidth = window.innerWidth - drawerWidth;
				renderHeight = window.innerHeight - titleHeight;
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setClearColor(0xffffff, 1);
				renderer.setSize(renderWidth, renderHeight);
				container.appendChild(renderer.domElement);

				//

				raycaster = new THREE.Raycaster();
				raycaster.params.Points.threshold = threshold;

				//

				stats = new Stats();
				container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			}

			function onDocumentMouseMove( event ) {

				mouseHasMoved = true;

				titleHeight = document.getElementById("header").clientHeight;

				if (window.innerWidth >= 1024) {
					drawerWidth = document.getElementById("drawer").clientWidth;
					mouse.x = ( (event.clientX - drawerWidth) / renderWidth ) * 2 - 1;
				} else {
					mouse.x = ( event.clientX /renderWidth ) * 2 - 1;
				}
				mouse.y = - ( (event.clientY - titleHeight) / (renderHeight)) * 2 + 1;
			}

			function onWindowResize() {

				renderWidth = window.innerWidth - drawerWidth;
				renderHeight = window.innerHeight - titleHeight;

				camera.aspect = renderWidth / renderHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( renderWidth, renderHeight );

			}

			function animate() {

				requestAnimationFrame(animate);

				if (interpolating) {
					pointclouds[0].geometry.attributes.position.needsUpdate = true;

					var positions = pointclouds[0].geometry.attributes.position.array;

					interpolatingAmount += interpolationSpeed;

					if (interpolatingAmount >= 1.0) {
						interpolating = false;

						for (var i = 0; i < positions.length; ++i) {
							positions[i] = target[i];
						}
					} else {

						for (var i = 0; i < positions.length; i += 3) {
							positions[i] = THREE.Math.lerp(positions[i], target[i], interpolatingAmount);
							positions[i+1] = THREE.Math.lerp(positions[i+1], target[i+1], interpolatingAmount);
						}
					}
				}


				render();
				stats.update();

			}

			var toggle = 0;
			var currentSound = null;

			function render() {

				raycaster.setFromCamera(mouse, camera);

				var intersections = raycaster.intersectObjects( pointclouds );
				intersection = (intersections.length) > 0 ? intersections[0] : null;

				if (toggle > 0.02 && intersection !== null && mouseHasMoved) {

					if (previousSampleIndex != intersection.index) {
						let filepath = filePaths[intersection.index];
						previousSampleIndex = intersection.index;

						// if (playPromise !== undefined) {
						// 	playPromise.then(_ => {
						// 		// Automatic playback started!
						// 		// Show playing UI.
						// 		// We can now safely pause video...
						// 		sound.pause();
						// 		sound.src = '';
						// 		sound.load("vengance_dataset/" + filepath);
						// 		sound.volume = 0.2;
						// 		playPromise = sound.play();
						// 	})
						// 	.catch(error => {
						// 		// Auto-play was prevented
						// 		// Show paused UI.
						// 	});
						// }
						//
						// if (sound == null) {
						// 	sound = new Audio("vengance_dataset/" + filepath);
						// }
						//
						// sound.volume = 0.2;
						// var playPromise = sound.play();

						// load a sound and play it immediatly
						let file = "audio/" + filepath;
					    WebAudiox.loadBuffer(context, file, function(buffer) {
					        // init AudioBufferSourceNode
					        var source  = context.createBufferSource();
					        source.buffer = buffer
					        source.connect(lineOut.destination)

							// start the sound now
							if (currentSound == null) {
								source.start(0);
								currentSound = source;
							}
							else {
								currentSound.stop(0)
								currentSound = source
								currentSound.start(0)
							}
					    });

						document.getElementById("filename").innerHTML = filepath;
					}

					spheres[spheresIndex].position.copy(intersection.point);
					spheres[spheresIndex].scale.set(1, 1, 1);
					spheresIndex = (spheresIndex + 1) % spheres.length;

					toggle = 0;

				}

				for (var i = 0; i < spheres.length; i++) {

					var sphere = spheres[i];
					sphere.scale.multiplyScalar(0.98);
					sphere.scale.clampScalar(0.01, 1);

				}

				toggle += clock.getDelta();

				renderer.render(scene, camera);

			}


		</script>

	</body>

</html>
